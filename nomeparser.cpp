//#include "parser.cpp"
//#include "lexer.cpp"
#include "nomeparser.h"


//namespace parserNom
//{
// This header is generated by Flex.
#include "lexer.cpp"

// This header is generated by bison.
#include "parser.cpp"
//}

NomeParser::NomeParser()
{

}


bool testComments(string token)
{

    if(token[0] == '#') {
        return true;
    }
    return false;
}

/**
 * @brief warning: Helper function to output warnings.
 * @param type:
 *          0: Parameter reading error.
 *          1: Stoi exception. Line skipped.
 * @param lineNumber: The current line number.
 * @return
 */
string warning(int type, int lineNumber)
{
    switch(type)
    {
    case 0:
        return "Warning: parameter at line "
                + to_string(lineNumber) + " is not set because of insufficient parameters.";
    case 1:
        return "Warning: line " + to_string(lineNumber)
                + " contains string that can't be parsed, skipping this line.";
    case 2:
        return "Warning: parameter at line "
                + to_string(lineNumber) + " has duplicated names of existing parameters.";
    case 3:
        return "Warning: mesh at line "
                + to_string(lineNumber) + " has duplicated names of existing meshes.";
    case 4:
        return "Warning: group at line "
                + to_string(lineNumber) + " has duplicated names of existing groups.";
    case 5:
        return "Warninng: instance at line "
                + to_string(lineNumber) + " has not been created yet.";
    case 6:
        return "Warning: new instance at line"
                + to_string(lineNumber) + " does not have a name.";
    case 7:
        return "Warning: parameter name at line"
                + to_string(lineNumber) + " does not match any defined parameter.";
    case 8:
        return "Warning: parameter at line"
                + to_string(lineNumber) + " does not have a retored value.";
    case 9:
        return "Warning: vertex at line"
                + to_string(lineNumber) + " can't be restored.";
    case 10:
        return "Warning: point at line"
                + to_string(lineNumber) + " doesn't have a name. It can't be initiated.";
    case 11:
        return "Warning: point at line"
                + to_string(lineNumber) + " has already been created (duplicate names)." +
                                          " It can't be initiated.";
    case 12:
        return "Warning: polyline at line"
                + to_string(lineNumber) + " doesn't have a name. It can't be initiated.";
    case 13:
        return "Warning: polyline at line"
                + to_string(lineNumber) + " has already been created (duplicate names)." +
                                          " It can't be initiated.";
    case 14:
        return "Warning: vertex at line"
                + to_string(lineNumber) + " can't be added to polyline. It has not been created.";
    case 15:
        return "Warning: Color at line"
                + to_string(lineNumber) + " can't be assigned. It has not been created.";
    case 16:
        return "Warning: Color at line"
                + to_string(lineNumber) + " has already been created (duplicate names).";
    case 17:
        return "Warning: Color at line"
                + to_string(lineNumber) + " does not have enough input.";
    case 18:
        return "Warning: Instance at line"
                + to_string(lineNumber) + " does not complete color definition. " +
                "It can't be instantiated.";
    case 19:
        return "Warning: face at line"
                + to_string(lineNumber) + " doesn't have a name. It can't be initiated.";
    case 20:
        return "Warning: face at line"
                + to_string(lineNumber) + " has already been created (duplicate names)." +
                                          " It can't be initiated.";
    case 21:
        return "Warning: vertex at line"
                + to_string(lineNumber) + " can't be added to face. It has not been created.";

    case 22:
        return "Warning: Face at line"
                + to_string(lineNumber) + " does not complete color definition. " +
                "It can't be instantiated.";
    case 23:
        return "Warning: face at line"
                + to_string(lineNumber) + " can't be added to mesh. It has not been created.";

    case 24:
        return "Warning: face at line"
                + to_string(lineNumber) + " can't be deleted. It does not have a name.";

    case 25:
        return "Warning: face at line"
                + to_string(lineNumber) + " can't be deleted. It is not in the current scene.";

    case 26:
        return "Warning: mesh at line"
                + to_string(lineNumber) + " doesn't have a name.";
    case 27:
        return "Warning: face at line"
                + to_string(lineNumber) + " can't be added to mesh. The mesh does not have a name.";

    }
    return "";
}

std::vector<std::string> reservedWords{"#", "\n", "point", "endpoint", "surface",
                                   "endsurface", "face", "endface", "object",
                                   "endobject", "bank", "endbank", "mesh",
                                   "endmesh", "tunnel", "endtunnel", "funnel",
                                   "endfunnel", "polyline", "endpolyline","instance"
                                   "endinstance", "delete", "enddelete", "group",
                                   "endgroup", "translate", "rotate", "mirror"};



int parser(string fileName){



    FILE *fileParser;
    int size;
    std::string buffer = "";
    // Opens the file
    currSession->saveFileToStr(fileName);

    fileParser = fopen(fileName.c_str(), "r");
    if (fileParser == NULL) return NULL;

    char previousC = ' ';
    char c = getc(fileParser);

    // Iterate through the file
    while (c != EOF){
        // Check for comments using #
        if (c == '#'){
            while (c != '\n' && c != EOF){
                c = getc(fileParser);
            }
        }
        else if (c == '('){
            previousC = c;
            c = getc(fileParser);
            // Check if the ( is in fact a comment
            if ((c == '*') && (previousC == '(')){
                cout << "COMMENT" << endl;
            }
        }
        else{
            c = getc(fileParser);
        }

    }

    return 0;
}

Session* NomeParser::makeWithNome(vector<ParameterBank> &banks,
                              unordered_map<string, Parameter> &params,
                              Group &group,
                              string input,
                              vector<string> &colorlines,
                              vector<string> &banklines,
                              vector<string> &geometrylines,
                              vector<int> &postProcessingLines,
                              vector<string> &postProcessingLinesString,
                              unordered_map<string, Vertex*> &global_vertices, unordered_map<string, Face*> &global_faces)
{
    currSession->saveFileToStr(input);
    nomin = fopen(input.c_str(), "r");
    nomparse();


    return currSession;


}



int NomeParser::postProcessingWithNome(unordered_map<string, Parameter> &params,
                                        vector<int> &postProcessingLines,
                                        SlideGLWidget *canvas,
                                        Group &group,
                                        string input, vector<string> &postProcessingLinesString, unordered_map<string, Vertex*> &global_vertices, unordered_map<string, Face*> &global_faces)
{
    if(postProcessingLines.size() == 0)
    {
        return 0;
    }
    ifstream file(input);
    if (!file.good())
    {
        cout<<"THE PATH OF MINI SIF FILE IS NOT VAILD.";
        exit(1);
    }
    string nextLine;
    int lineNumber = 1;
    bool deletePhase = false;
    bool restoreConsolidatedMesh = false;
    string current_mesh_name = "";
    unordered_map<string, QColor> user_defined_colors;
    unordered_map<string, QColor>::iterator colorIt;
    vector<int>::iterator fileLineIter = postProcessingLines.begin();
    unordered_map<string, Mesh> meshes;
    unordered_map<string, Mesh>::iterator meshIt;
    unordered_map<string, Face*>::iterator faceIt;


    while(std::getline(file, nextLine))
    {
        istringstream iss(nextLine);
        vector<string> tokens;
        copy(istream_iterator<string>(iss),
             istream_iterator<string>(),
             back_inserter(tokens));
        vector<string>::iterator tIt;

        for(tIt = tokens.begin(); tIt < tokens.end(); tIt++)
        {
            if((*tIt) != "surface" && lineNumber != (*fileLineIter))
            {
                goto newLineEnd;
            }
            else if((*tIt) == "surface")
            {
                string color_name;
                QColor new_color;
                if(++tIt < tokens.end())
                {
                    color_name = (*tIt);
                    colorIt = user_defined_colors.find(color_name);
                    if(colorIt != user_defined_colors.end())
                    {
                        cout<<warning(16, lineNumber)<<endl;
                        goto newLineEnd;
                    }
                }
                else
                {
                    cout<<warning(17, lineNumber)<<endl;
                }
                if(++tIt < tokens.end())
                {
                    if((*tIt) != "color")
                    {
                        cout<<warning(17, lineNumber)<<endl;
                    }
                }
                else
                {
                    cout<<warning(17, lineNumber)<<endl;
                }
                string color_expression;
                bool expression_input = false;
                bool inExpression = false;
                while(++tIt < tokens.end())
                {
                    for(char& c : (*tIt))
                    {
                        if(c == '(' && !inExpression)
                        {
                            expression_input = true;
                        }
                        else if(c == ')' && !inExpression)
                        {
                            expression_input = false;
                            goto colordone;
                        }
                        else if(c == '#')
                        {
                            goto newLineEnd;
                        }
                        else if(expression_input)
                        {
                            color_expression.push_back(c);
                        }
                        if(c == '{')
                        {
                            inExpression = true;
                        }
                        else if(c == '}')
                        {
                            inExpression = false;
                        }
                    }
                    color_expression.push_back(' ');
                }
                colordone:
                new_color = evaluate_color_expression(color_expression, lineNumber);

                user_defined_colors[color_name] = new_color;
                goto newLineEnd;
            }
            else
            {
                fileLineIter++;
            }
            if((*tIt) == "mesh")
            {
                restoreConsolidatedMesh = true;
                Mesh newMesh(0);
                if((++tIt) < tokens.end()) {
                    if(!testComments(*tIt))
                    {
                        newMesh.name = *tIt;
                        //cout << params << endl;
                        newMesh.setGlobalParameter(&params);
                    }
                    else
                    {
                        cout<<warning(26, lineNumber)<<endl;
                        goto newLineEnd;
                    }
                }
                else
                {
                    cout<<warning(26, lineNumber)<<endl;
                    goto newLineEnd;
                }

                if(canvas->meshes.find(newMesh.name) == canvas->meshes.end())
                {
                    canvas->meshes[newMesh.name] = newMesh;
                    current_mesh_name = newMesh.name;
                }
                else
                {
                    cout<<warning(3, lineNumber)<<endl;
                }
                goto newLineEnd;
            }
            else if((*tIt) == "endmesh")
            {
                restoreConsolidatedMesh = false;
                goto newLineEnd;
            }
            else if((*tIt) == "delete")
            {
                deletePhase = true;
                goto newLineEnd;
            }
            else if((*tIt) == "enddelete")
            {
                deletePhase = false;
                goto newLineEnd;
            }
            else if((*tIt) == "face" && deletePhase)
            {
                string deleteFaceName = "";
                if(++tIt < tokens.end())
                {
                    deleteFaceName = *tIt;
                }
                else
                {
                    cout<<warning(24, lineNumber)<<endl;
                    goto newLineEnd;
                }
                //cout<<deleteFaceName<<endl;
                bool found = (canvas
                              -> hierarchical_scene_transformed).deleteFaceInThisGroup(deleteFaceName);
                if(!found)
                {
                    found = (canvas -> group_from_consolidate_mesh)->deleteFaceInThisGroup(deleteFaceName);
                    if(!found)
                    {
                        cout<<warning(25, lineNumber)<<endl;
                    }
                }
                goto newLineEnd;
            }
            else if((*tIt) == "face" && restoreConsolidatedMesh)
            {
                Face * newFace = new Face;
                if((++tIt) < tokens.end()) {

                    if(!testComments(*tIt))
                    {

                        faceIt = global_faces.find(*tIt);

                        bool sameFaceName = false;
                        int i = 0;
                        while (i < canvas->meshes[current_mesh_name].faceList.size()){
                            if ((*tIt).compare(canvas->meshes[current_mesh_name].faceList[i] -> name) == 0){
                                sameFaceName  = true;
                            }
                            i++;
                        }

                        if (sameFaceName){
                            cout<<warning(20, lineNumber)<<endl;
                            return 1;
                        }
                        newFace -> name = *tIt;
                        global_faces[*tIt] = newFace;

                        /*if(faceIt == global_faces.end())
                        {
                            newFace -> name = *tIt;
                            global_faces[*tIt] = newFace;
                        }
                        else
                        {

                            cout << "OOOPS" << endl;
                            cout<<warning(20, lineNumber)<<endl;
                        }*/
                    }
                    else
                    {
                        cout<<warning(19, lineNumber)<<endl;
                    }
                }
                string vertInside = "";
                bool addingVert = false;
                vector<Vertex*> vertices;
                vertices.clear();

                while(++tIt < tokens.end() && (*tIt) != "endface")
                {
                    for(char & c: (*tIt))
                    {
                        if(c == '(')
                        {
                            addingVert = true;
                        }
                        else if(c == ')')
                        {
                            addingVert = false;

                            if(vertInside != "")
                            {
                                Vertex *v = (canvas -> hierarchical_scene_transformed).findVertexInThisGroup(vertInside);

                                if (v == NULL){
                                    //cout << group.findVertexInThisGroup(vertInside)->name << endl;
                                    //v = (canvas -> consolidate_mesh).findVertexInThisGroup(vertInside);
                                    v = group.findVertexInThisGroup(vertInside);
                                    //cout << "FOUND" << endl;
                                    //cout << v->name << endl;
                                    //cout << "HELLO" << endl;
                                }
                                //cout << v->name << endl;
                                if(!(canvas -> master_mesh.isEmpty())) /* Dealing with recovery of SIF.*/
                                {
                                    v = (canvas -> master_mesh.findVertexInThisMesh(vertInside));
                                }

                                //cout << "===" << endl;
                                //cout << canvas->hierarchical_scene_transformed.myMeshes.size() << endl;
                                //cout << canvas->hierarchical_scene_transformed.myPolylines.size() << endl;
                                //cout << canvas->hierarchical_scene_transformed.subgroups.size() << endl;


                                if(v == NULL)
                                {
                                    /*for (Mesh m: canvas->group_from_consolidate_mesh->myMeshes){
                                        cout << m.name << endl;
                                    }*/

                                    canvas -> set_to_editing_mode(true);
                                    canvas -> updateFromSavedMesh();
                                    v = canvas->group_from_consolidate_mesh->findVertexInThisGroup(vertInside);
                                    //cout << v->name << endl;
                                    //cout << canvas->hierarchical_scene_transformed.myMeshes.size() << endl;
                                    //v = group.findVertexInThisGroup(vertInside);
                                    //cout << v->name << endl;
                                    if(v == NULL)
                                    {
                                        unordered_map<string, Vertex*>::iterator vertIt;
                                        vertIt = global_vertices.find(vertInside);

                                        if(vertIt != global_vertices.end())
                                        {
                                            v=vertIt -> second;
                                        }
                                        else
                                        {
                                            cout<<warning(9, lineNumber)<<endl;
                                            return 1;
                                        }
                                    }
                                    vertices.push_back(v);
                                }
                                else
                                {
                                    vertices.push_back(v);
                                }
                                vertInside = "";
                            }
                            goto endAddingVertInFace;
                        }
                        else if(addingVert)
                        {
                            vertInside.push_back(c);
                        }

                    }
                    if(vertInside != "")
                    {
                        Vertex *v = (canvas -> hierarchical_scene_transformed).findVertexInThisGroup(vertInside);

                        if (v == NULL){
                            //cout << group.findVertexInThisGroup(vertInside)->name << endl;
                            //v = (canvas -> consolidate_mesh).findVertexInThisGroup(vertInside);
                            v = group.findVertexInThisGroup(vertInside);
                            //cout << "FOUND" << endl;
                            //cout << v->name << endl;
                            //cout << "HELLO" << endl;
                        }
                        //cout << v->name << endl;
                        if(!(canvas -> master_mesh.isEmpty())) /* Dealing with recovery of SIF.*/
                        {
                            v = (canvas -> master_mesh.findVertexInThisMesh(vertInside));
                        }

                        //cout << "===" << endl;
                        //cout << canvas->hierarchical_scene_transformed.myMeshes.size() << endl;
                        //cout << canvas->hierarchical_scene_transformed.myPolylines.size() << endl;
                        //cout << canvas->hierarchical_scene_transformed.subgroups.size() << endl;


                        if(v == NULL)
                        {
                            /*for (Mesh m: canvas->group_from_consolidate_mesh->myMeshes){
                                cout << m.name << endl;
                            }*/

                            canvas -> set_to_editing_mode(true);
                            canvas -> updateFromSavedMesh();
                            v = canvas->group_from_consolidate_mesh->findVertexInThisGroup(vertInside);
                            //cout << v->name << endl;
                            //cout << canvas->hierarchical_scene_transformed.myMeshes.size() << endl;
                            //v = group.findVertexInThisGroup(vertInside);
                            //cout << v->name << endl;
                            if(v == NULL)
                            {
                                unordered_map<string, Vertex*>::iterator vertIt;
                                vertIt = global_vertices.find(vertInside);

                                if(vertIt != global_vertices.end())
                                {
                                    v=vertIt -> second;
                                }
                                else
                                {
                                    cout<<warning(9, lineNumber)<<endl;
                                    return 1;
                                }
                            }
                            vertices.push_back(v);
                        }
                        else
                        {
                            vertices.push_back(v);
                        }
                        vertInside = "";
                    }
                }
                endAddingVertInFace:
                /* Add this face to the current mesh.*/
                vector<Vertex*> mappedVertices;
                mappedVertices.clear();
                bool foundVertex;
                for(Vertex * vs : vertices)
                {
                    //cout << vs->name << endl;
                    foundVertex = false;
                    for(Vertex * v : canvas->meshes[current_mesh_name].vertList)
                    {
                        //cout << v->ID << endl;
                        if(v -> source_vertex == vs)
                        {
                            foundVertex = true;
                            mappedVertices.push_back(v);
                            break;
                        }
                    }

                    if(!foundVertex)
                    {
                        Vertex * newVertex = new Vertex;
                        newVertex -> isParametric = vs -> isParametric;
                        newVertex -> position = vs -> position;
                        newVertex -> ID = canvas->meshes[current_mesh_name].vertList.size();
                        newVertex -> source_vertex = vs;
                        newVertex -> name = vs -> name;
                        newVertex -> x_expr = vs -> x_expr;
                        newVertex -> y_expr = vs -> y_expr;
                        newVertex -> z_expr = vs -> z_expr;
                        newVertex -> influencingParams = vs -> influencingParams;
                        newVertex -> params = vs -> params;
                        canvas->meshes[current_mesh_name].addVertex(newVertex);
                        mappedVertices.push_back(newVertex);
                    }
                }

                canvas->meshes[current_mesh_name].addPolygonFace(mappedVertices);
                canvas->meshes[current_mesh_name].faceList[canvas->meshes[current_mesh_name].faceList.size() - 1]
                        -> name = newFace -> name;

                if(++tIt < tokens.end() && (*tIt) == "surface")
                {
                    string color_name = "";
                    QColor color;
                    bool foundColor = false;
                    if(++tIt < tokens.end())
                    {
                        color_name = *tIt;
                        colorIt = user_defined_colors.find(color_name);
                        if(colorIt != user_defined_colors.end())
                        {
                            foundColor = true;
                            color = colorIt -> second;
                        }
                        else
                        {
                            cout<<warning(22, lineNumber)<<endl;
                        }
                    }
                    else
                    {
                        cout<<warning(22, lineNumber)<<endl;
                    }
                    if(foundColor)
                    {
                        canvas->meshes[current_mesh_name].faceList[canvas->meshes[current_mesh_name].faceList.size() - 1]
                                -> color = color;
                        canvas->meshes[current_mesh_name].faceList[canvas->meshes[current_mesh_name].faceList.size() - 1]
                                -> user_defined_color = true;
                    }
                }
                delete newFace;


            }
            else if((*tIt) == "instance")
            {
                string instanceName;
                Mesh newMesh;
                string className;
                bool findMesh = false;
                bool foundColor = false;
                QColor color;
                if((++tIt) < tokens.end())
                {
                    if(!testComments(*tIt))
                    {
                        instanceName = *tIt;
                    }
                }
                else
                {
                    cout<<warning(5, lineNumber)<<endl;
                }
                //cout << instanceName << endl;

                if((++tIt) < tokens.end())
                {
                    if(!testComments(*tIt))
                    {
                        className = *tIt;
                        //cout << className << endl;
                    }
                }
                else
                {
                    cout<<warning(6, lineNumber)<<endl;
                }

                meshIt = canvas->meshes.find(className);
                if(meshIt != canvas->meshes.end())
                {
                    newMesh = (meshIt -> second).makeCopyForTempMesh(instanceName);
                    findMesh = true;
                }

                vector<Transformation> transformations_up;
                while(++tIt < tokens.end() && (*tIt) != "endinstance")
                {
                    if(testComments(*tIt))
                    {
                        goto newLineEnd;
                    }
                    if(*tIt == "rotate")
                    {
                        string xyz;
                        string angle;
                        bool makingXYZ = false;
                        bool makingAngle = false;
                        bool doneXYZ = false;
                        bool inExpression = false;
                        while(++tIt < tokens.end() && (*tIt) != "endinstance")
                        {
                            for(char& c : (*tIt))
                            {
                                if(c == '(' && !inExpression)
                                {
                                    if(!doneXYZ)
                                    {
                                        makingXYZ = true;
                                    }
                                    else
                                    {
                                        makingAngle = true;
                                    }
                                }
                                else if(c == ')' && !inExpression)
                                {
                                    if(makingXYZ)
                                    {
                                        doneXYZ = true;
                                        makingXYZ = false;
                                    } else if(makingAngle)
                                    {
                                        makingAngle = false;
                                        goto endWhile1;
                                    }
                                }
                                else
                                {
                                    if(makingXYZ)
                                    {
                                        xyz.push_back(c);
                                        if(c == '{')
                                        {
                                            inExpression = true;
                                        }
                                        else if(c == '}')
                                        {
                                            inExpression = false;
                                        }
                                    }
                                    else if(makingAngle)
                                    {
                                        angle.push_back(c);
                                        if(c == '{')
                                        {
                                            inExpression = true;
                                        }
                                        else if(c == '}')
                                        {
                                            inExpression = false;
                                        }
                                    }
                                }
                            }
                            if(makingXYZ && xyz != "")
                            {
                                xyz.push_back(' ');
                            }
                            else if(makingAngle && angle != "")
                            {
                                angle.push_back(' ');
                            }
                        }
                        endWhile1:
                        Transformation t(1, &params, xyz, angle);
                        transformations_up.push_back(t);
                    }
                    else if(*tIt == "translate" || *tIt == "scale")
                    {
                        bool isTranslate = false;
                        if(*tIt == "translate")
                        {
                            isTranslate = true;
                        }
                        string xyz = "";
                        bool makingXYZ = false;
                        bool inExpression = false;
                        while(++tIt < tokens.end() && (*tIt) != "endinstance")
                        {
                            for(char& c : (*tIt))
                            {
                                if(c == '(' && !inExpression)
                                {
                                    makingXYZ = true;
                                }
                                else if(c == ')' && !inExpression)
                                {
                                    makingXYZ = false;
                                    goto endWhile2;
                                }
                                else if(makingXYZ)
                                {
                                    xyz.push_back(c);
                                    if(c == '{')
                                    {
                                        inExpression = true;
                                    }
                                    else if(c == '}')
                                    {
                                        inExpression = false;
                                    }
                                }
                            }
                            if(xyz != "")
                            {
                                xyz.push_back(' ');
                            }
                        }
                        endWhile2:
                        if(isTranslate)
                        {
                            Transformation t(3,&params, xyz);
                            transformations_up.push_back(t);
                        }
                        else
                        {
                            Transformation t(2, &params, xyz);
                            transformations_up.push_back(t);
                        }
                    }
                    else if(*tIt == "mirror")
                    {
                        string xyzw = "";
                        bool makingXYZW = false;
                        bool inExpression = false;
                        while(++tIt < tokens.end() && (*tIt) != "endinstance")
                        {
                            for(char& c : (*tIt))
                            {
                                if(c == '(' && !inExpression)
                                {
                                    makingXYZW = true;
                                }
                                else if(c == ')' && !inExpression)
                                {
                                    makingXYZW = false;
                                    goto endWhile3;
                                }
                                else if(makingXYZW)
                                {
                                    xyzw.push_back(c);
                                    if(c == '{')
                                    {
                                        inExpression = true;
                                    }
                                    else if(c == '}')
                                    {
                                        inExpression = false;
                                    }
                                }
                            }
                            if(xyzw != "")
                            {
                                xyzw.push_back(' ');
                            }
                        }
                        endWhile3:
                        Transformation t(4, &params, xyzw);
                        transformations_up.push_back(t);
                    }
                    if(*tIt == "surface")
                    {
                        string color_name;
                        if(++tIt < tokens.end())
                        {
                            color_name = *tIt;
                            colorIt = user_defined_colors.find(color_name);
                            if(colorIt != user_defined_colors.end())
                            {
                                color = colorIt -> second;
                                foundColor = true;
                            }
                            else
                            {
                                cout<<warning(18, lineNumber)<<endl;
                            }
                        }
                        else
                        {
                            cout<<warning(18, lineNumber)<<endl;
                        }
                    }
                }
                if(findMesh)
                {

                    newMesh.setTransformation(transformations_up);
                    if(foundColor)
                    {
                        newMesh.setColor(color);
                        newMesh.user_set_color = true;
                    }
                    group.addMesh(newMesh);
                }
                else
                {
                    cout<<"Error: there is a bug in the program. Check!"<<endl;
                }
                //cout << "MESH UPDATED" << endl;
                //cout << newMesh.name << endl;
                //canvas -> set_to_editing_mode(true);
                //canvas -> updateFromSavedMesh();
            }
            else
            {
                //cout<<nextLine<<endl;
                goto newLineEnd;
            }
        }
    newLineEnd:
    lineNumber++;
    }

    canvas -> set_to_editing_mode(true);
    canvas -> updateFromSavedMesh();
}

void NomeParser::appendWithANOM(unordered_map<string, Parameter> &params,
                                Group &group,
                                SlideGLWidget* canvas,
                                string input)
{

    ifstream file(input);
    if (!file.good())
    {
        cout<<"THE PATH OF MINI SIF FILE IS NOT VAILD.";
        exit(1);
    }
    string nextLine;
    int lineNumber = 1;
    bool restoreBank = false;
    bool restoreConsolidateMesh = false;
    unordered_map<string, Parameter>::iterator pIt;
    vector<Vertex*> restore_vertices;
    unordered_map<string, Group> groups;
    string currentGroup = "";
    while(std::getline(file, nextLine))
    {
        istringstream iss(nextLine);
        vector<string> tokens;
        copy(istream_iterator<string>(iss),
             istream_iterator<string>(),
             back_inserter(tokens));
        vector<string>::iterator tIt;
        for(tIt = tokens.begin(); tIt < tokens.end(); tIt++)
        {
            if(testComments(*tIt))
            {
                break;
            }
            else if((*tIt) == "savedparameter")
            {
                restoreBank = true;
                goto newLineEnd;
            }
            else if((*tIt) == "endsavedparameter")
            {
                restoreBank = false;
                goto newLineEnd;
            }
            else if((*tIt) == "consolidate")
            {
                restoreConsolidateMesh = true;
                goto newLineEnd;
            }
            else if((*tIt) == "endconsolidate")
            {
                restoreConsolidateMesh = false;
                goto newLineEnd;
            }
            else if(restoreBank)
            {
                pIt = params.find(*tIt);
                if(pIt == params.end())
                {
                    cout<<warning(7, lineNumber)<<endl;
                }
                else
                {
                    tIt++;
                    if(tIt >= tokens.end() || testComments(*tIt))
                    {
                        cout<<warning(8, lineNumber)<<endl;
                    }
                    else
                    {
                        float value = stof(*tIt);
                        (pIt -> second).changeParameterValue(value);
                    }
                }
                goto newLineEnd;
            }
            else if(restoreConsolidateMesh)
            {
                if(*tIt == "consolidateface")
                {
                    restore_vertices.clear();
                    goto newLineEnd;
                }
                else if(*tIt == "endconsolidateface")
                {
                    canvas->consolidate_mesh.addPolygonFace(restore_vertices);
                    goto newLineEnd;
                }
                else if(*tIt == "vertex")
                {
                    tIt++;
                    if(tIt >= tokens.end() || testComments(*tIt))
                    {

                        cout<<warning(9, lineNumber)<<endl;
                    }
                    Vertex *v = (canvas -> hierarchical_scene_transformed).findVertexInThisGroup(*tIt);
                    if(!(canvas -> master_mesh.isEmpty())) /* Dealing with recovery of SIF.*/
                    {
                        v = (canvas -> master_mesh.findVertexInThisMesh(*tIt));
                    }
                    if(v == NULL)
                    {

                        cout<<warning(9, lineNumber);
                    }
                    else
                    {
                        (canvas -> consolidate_mesh).addVertex(v);
                        restore_vertices.push_back(v);
                    }
                    goto newLineEnd;
                }
            }
            else if((*tIt) == "instance")
            {

                //cout << "HELFFD" << endl;
                string instanceName;
                Mesh newMesh;
                string className;
                if((++tIt) < tokens.end()) {
                    if(!testComments(*tIt))
                    {
                        instanceName = *tIt;
                    }
                }
                else
                {
                    cout<<warning(5, lineNumber);
                }
                if((++tIt) < tokens.end()) {
                    if(!testComments(*tIt))
                    {
                        className = *tIt;
                    }
                }
                else
                {
                    cout<<warning(6, lineNumber);
                }
                if(className == "consolidatemesh")
                {

                    newMesh = (canvas -> consolidate_mesh).makeCopyForTempMesh(instanceName);
                }
                else
                {
                    goto newLineEnd;
                }
                vector<Transformation> transformations_up;
                while(++tIt < tokens.end() && (*tIt) != "endinstance")
                {
                    if(testComments(*tIt))
                    {
                        goto newLineEnd;
                    }
                    if(*tIt == "rotate")
                    {
                        string xyz;
                        string angle;
                        bool makingXYZ = false;
                        bool makingAngle = false;
                        bool doneXYZ = false;
                        bool inExpression = false;
                        while(++tIt < tokens.end() && (*tIt) != "endinstance")
                        {
                            for(char& c : (*tIt))
                            {
                                if(c == '(' && !inExpression)
                                {
                                    if(!doneXYZ)
                                    {
                                        makingXYZ = true;
                                    }
                                    else
                                    {
                                        makingAngle = true;
                                    }
                                }
                                else if(c == ')' && !inExpression)
                                {
                                    if(makingXYZ)
                                    {
                                        doneXYZ = true;
                                        makingXYZ = false;
                                    } else if(makingAngle)
                                    {
                                        makingAngle = false;
                                        goto endWhile1;
                                    }
                                }
                                else
                                {
                                    if(makingXYZ)
                                    {
                                        xyz.push_back(c);
                                        if(c == '{')
                                        {
                                            inExpression = true;
                                        }
                                        else if(c == '}')
                                        {
                                            inExpression = false;
                                        }
                                    }
                                    else if(makingAngle)
                                    {
                                        angle.push_back(c);
                                        if(c == '{')
                                        {
                                            inExpression = true;
                                        }
                                        else if(c == '}')
                                        {
                                            inExpression = false;
                                        }
                                    }
                                }
                            }
                            if(makingXYZ && xyz != "")
                            {
                                xyz.push_back(' ');
                            }
                            else if(makingAngle && angle != "")
                            {
                                angle.push_back(' ');
                            }
                        }
                        endWhile1:
                        Transformation t(1, &params, xyz, angle);
                        transformations_up.push_back(t);
                    }
                    else if(*tIt == "translate" || *tIt == "scale")
                    {
                        bool isTranslate = false;
                        if(*tIt == "translate")
                        {
                            isTranslate = true;
                        }
                        string xyz = "";
                        bool makingXYZ = false;
                        bool inExpression = false;
                        while(++tIt < tokens.end() && (*tIt) != "endinstance")
                        {
                            for(char& c : (*tIt))
                            {
                                if(c == '(' && !inExpression)
                                {
                                    makingXYZ = true;
                                }
                                else if(c == ')' && !inExpression)
                                {
                                    makingXYZ = false;
                                    goto endWhile2;
                                }
                                else if(makingXYZ)
                                {
                                    xyz.push_back(c);
                                    if(c == '{')
                                    {
                                        inExpression = true;
                                    }
                                    else if(c == '}')
                                    {
                                        inExpression = false;
                                    }
                                }
                            }
                            if(xyz != "")
                            {
                                xyz.push_back(' ');
                            }
                        }
                        endWhile2:
                        if(isTranslate)
                        {
                            Transformation t(3,&params, xyz);
                            transformations_up.push_back(t);
                        }
                        else
                        {
                            Transformation t(2, &params, xyz);
                            transformations_up.push_back(t);
                        }
                    }
                    else if(*tIt == "mirror")
                    {
                        string xyzw = "";
                        bool makingXYZW = false;
                        bool inExpression = false;
                        while(++tIt < tokens.end() && (*tIt) != "endinstance")
                        {
                            for(char& c : (*tIt))
                            {
                                if(c == '(' && !inExpression)
                                {
                                    makingXYZW = true;
                                }
                                else if(c == ')' && !inExpression)
                                {
                                    makingXYZW = false;
                                    goto endWhile3;
                                }
                                else if(makingXYZW)
                                {
                                    xyzw.push_back(c);
                                    if(c == '{')
                                    {
                                        inExpression = true;
                                    }
                                    else if(c == '}')
                                    {
                                        inExpression = false;
                                    }
                                }
                            }
                            if(xyzw != "")
                            {
                                xyzw.push_back(' ');
                            }
                        }
                        endWhile3:
                        Transformation t(4, &params, xyzw);
                        transformations_up.push_back(t);
                    }
                }
                if(currentGroup != "")
                {
                    newMesh.setTransformation(transformations_up);
                    groups[currentGroup].addMesh(newMesh);
                }
                else
                {
                    newMesh.setTransformation(transformations_up);
                    group.addMesh(newMesh);
                }
                canvas -> updateFromSavedMesh();
            }

        }
        newLineEnd:
        lineNumber++;
    }
    canvas -> updateFromSavedMesh();
}
